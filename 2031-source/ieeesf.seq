 .PAGE 'IEEE.SF';;THE IEEE BUS HANDSHAKE LINES ARE;CONTROLLED FROM A VIA PORT B AND CA1;USING THE FOLLOWING LAYOUT:;;PB0: ATN OUT;PB1: NRFD (I/O);PB2: NDAC (I/O);PB3: EOI (I/O);PB4: TRANSMIT/RECEIVE CONTROL FOR BUFFER CHIPS;PB5: NOT USED FOR IEEE INTERFACE;PB6: DAV (I/O);PB7 / CA1: ATN IN (CAUSES IRQS);;;ATN IRQ PROCESS; IRQ ON ATN, LISTEN TO PET; CLEAR STACK .SKIP 3ATNIRQ LDA IEEED ; CLEAR IRQ FLAG LDA #1 ; SET ATN PENDING STA ATNPND ; FLAG RTS ; AND EXIT;;;ATNSRV SEI LDA #0 ; CLEAR PENDING FLAG STA ATNPND LDX #$45 ; INITIALIZE TXS ; STACK POINTER LDA #DAV+EOI+NDAC ORA PB AND #$FF-NRFD-TR ; SET RECEIVE MODE STA PB LDA #%00000000 ; DATA PORT IS STA DDRA1 ; ALL INPUTS LDA #TR+NRFD+NDAC+ATNA ; SET PINS TO OUTPUTS STA DDRB1 LDA #$FF ; DATA IS FALSE IN OUTPUT REGISTER STA IEEEDATN10 LDA PB ; GET BUS LINES AND #$FF-NDAC ; NDAC FALSE ORA #ATNA+NRFD ; ATN ACK AND NRFD TRUE STA PB ; SET BUSATN20 BIT PB ; GET BUS LINES BVC ATN30 ; IF DAV, GO EVALUATE COMMAND BMI ATN20 ; IF ATN, WAIT FOR ATN RELEASE BPL ATN50 ; ELSE CHECK IF WERE LISTENING (BRANCH ALWAYS);;ATN DROPPED, DAV TRUE, EVALUATE COMMANDATN30 LDA #$FF-NRFD ; SET NRFD FALSE (=READY FOR DATA) AND PB ; SET PORT DATA STA PB ; SET BUS AND #EOI ; GET EOI BIT STA EOIFLG ; SET EOI FLAG ACCORDINGLY LDA IEEED ; GET BUS DATA EOR #$FF ; INVERT IT STA ICMD ; AND STORE BUS COMMAND LDA #NDAC ; GET BIT MASK ORA PB ; SET NDAC TRUE STA PB ; ON BUSDCDE LDY #0 ; GET CLEAR STATE IN Y LDA ICMD ; GET BUS COMMAND BYTE AND #$60 ; GET COMMAND BITS CMP #$40 ; TALK? BEQ DCDE60 ; GO TALK CMP #$20 ; LISTEN? BEQ DCDE20 ; GO LISTEN CMP #$60 ; SECONADRY ADDRESS? BEQ DCDE70 ; GO HANDLE SECONDARY ADDRESS BNE DCDE80 ; ELSE OTHER, DO THOSE;;LISTEN COMMAND RECEIVEDDCDE20 LDA ICMD ; GET BUS COMMAND CMP LSNADR ; IS IT FOR US BEQ DCDE40 ; YES, GO LISTEN CMP #$3F ; IF UNLISTEN BNE DCDE30 STY LSNACT ; CLEAR LISTEN FLAGDCDE30 STY ADRSED ; SET NOT ADDRESSED JMP DCDE80 ; WAIT FOR NO DAV AND LOOP;; LISTEN TO IEEE488 BUS; DCDE40 STA LSNACT ; SAVE CURRENT LISTEN SA STY TLKACT ; CLEAR CURRENT TALK ADDRESSDCDE50 LDA #$20 ; CURRENT STATE IS LISTEN STA SA ; SET IT STA ORGSA STA ADRSED ; SET LISTEN ADDRESS BNE DCDE80 ; WAIT FOR NO DAV AND LOOP (BRANCH ALWAYS);; TALK TO IEEE448 BUS;DCDE60 STY TLKACT ; CLEAR TALK ACTIVE FLAG LDA ICMD ; GET COMMAND BYTE CMP TLKADR ; IF NOT FOR US BNE DCDE30 ; SET NOT ADDRESSED AND LOOP STA TLKACT ; FOR US, FLAG WE'RE TALKING STY LSNACT ; CLEAR LISTENING FLAG BEQ DCDE50 ; (BRANCH ALWAYS);;HANDLE SECONDARY ADDRESS; DCDE70 LDA ADRSED ; IF NOT ADDRESSED BEQ DCDE80 ; WAIT FOR NO DAV AND LOOP LDA ICMD ; ELSE GET COMMAND BYTE STA ORGSA ; SET CURRENT SECONDARY ADDRESS PHA ; SAVE IT AND #$0F ; STRIP THE COMMAND BITS STA SA ; AND SET AS TRUE SECONDARY ADDRESS PLA ; RESTORE COMMAND BYTE AND #$F0 ; GET COMMAND BITS CMP #$E0 ; IF CLOSE BNE DCDE80 CLI ; ALLOW INTERRUPTS JSR CLOSE ; PERFORM CLOSE SEI ; BLOCK INTERRUPTS, AND:; WAIT FOR NO DAV AND LOOPDCDE80ATN40 BIT PB ; WAIT BVC ATN40 ; FOR NO DAV JMP ATN10 ; AND LOOP;ATN50 LDA LSNACT ; IF WE ARE NOT LISTENING BEQ ATN60 ; FLAG DATA ACCEPTED LDA #$FF-NRFD-ATNA ; ELSE SET BOTH NRFD AND ATN AND PB ; FALSE STA PB ; ON BUS JSR LISTEN ; AND DO LISTEN JMP IDLE ; THEN IDLE BUS .SKIP 5 ATN60 LDA #$FF-NDAC-ATNA ; SET ATN AND NDAC AND PB ; FALSE (=DATA ACCEPTED) ORA #NDAC ; SET NDAC TRUE STA PB LDA TLKACT ; IF WE ARE NOT TALKING BEQ ATN70 ; GO IDLE BUS JSR TALK ; ELSE GO TALKATN70 JMP IDLE ; AND IDLE BUS .PAGE 'IEEELISN';;;LISTEN SEI ; NO INTERRUPTS LDA #NRFD ; SET NRFD ORA PB ; FALSE (=READY FOR DATA) STA PB ; ON BUSLSN10 BIT PB ; GET BUS STATUS BMI NOLATN ; IF ATN, SERVICE THAT BVS LSN10 ; IF DAV FALSE, WAIT FOR IT TO GO TRUE JSR FNDWCH ; GET BUFFER NUMBER IN X BCS LSN15 ; IF NO BUFFER AVAILABLE .SKIP 1 LDA CHNRDY,X ; ELSE ROR A ; OPEN FOR LISTEN BCS LSN30LSN15 LDA ORGSA ; TEST IF CLOSE AND #$F0 ; SECONDARY ADDRESS CMP #$F0 ; IS OPEN? BEQ LSN30LSN20 LDA SA ; GET SECONDARY ADDRESS CMP #$01 ; IF SAVING BEQ LSN25LSN21 BIT PB ; ELSE GET BUS STATUS BMI NOLATN ; IF ATN, GO SERVICE THAT BVC LSN21 ; IF DAV FALSE LDA #$FF-NDAC ; SET NDAC FALSE AND PB ; ON BUS STA PB ; AND RTS ; EXIT .SKIP 1NOLATN JMP ATNSRV ; SERVICE ATN;LSN25 SEI LDA #$FF-NRFD ; NRFD FALSE (=READY FOR DATA) AND PB ; ADD TO BUS LIMES STA PB ; AND SET BUS LDA #NDAC ; NDAC FALE (=DATA ACCEPTED) ORA PB ; SET BUS LINES STA PB ; AND SET BUSLSN28 BIT PB ; GET BUS STATE BMI NOLATN ; IF ATN, GO SERVICE BVC LSN28 ; IF NO DAV, WAIT FOR IT LDA PB ; IF DAV, GET BUS LINES AND #$FF-NDAC ; SET NDAC STA PB ; FALSE (=DATA ACCEPTED) LDA #NRFD ; SET NRFD TRUE ORA PB ; SET STA PB ; PORTLSN29 BIT PB ; IF ATN BMI NOLATN ; GO SERVICE BVC LSN29 ; IF NO DAV, WAIT FOR IT JMP LSN25 ; ELSE LOOP UNTIL ATN FALSE;LSN30 LDA #$FF-NRFD ; SET AND PB ; NRFD TRUE STA PB ; ON BUS AND #EOI ; GET EOI STA EOIFLG ; STORE ITS STATUS LDA IEEED ; GET BUS DATA EOR #$FF ; INVERT IT STA DATA ; AND STORE BYTE SEI ; NO INTERRUPTS LDA #NDAC ; SET ORA PB ; NDAC FALSE (=NOT ACCEPTED (YET)) STA PB ; ON BUSLSN40 BIT PB ; IF ATN BMI NOLATN ; GO SERVICE THAT BVC LSN40 ; IF NO DAV, WAIT FOR IT LDA #$FF-NDAC ; ELSE SET AND PB ; NDAC FALSE (=DATA ACCEPTED) STA PB ; ON BUS CLI ; ALLOW INTERRUPTS JSR PUT ; BUT RECEIVED BYTE IN CHANNEL JMP LISTEN ; AND KEEP LISTENING .SKIP 3TLK25 LDA #DAV+EOI ; DAV FALSE, EOI FALSE ORA PB ; ADD CURRENT BUS LINES STA PB ; SET BUS JMP IDLE ; AND IDLE BUS .PAGE 'IEEETLK';;TALK TO IEEE488 BUS; TALK SEI ; NO INTERRUPTS JSR FNDRCH ; FIND AN OPEN READ CHANNEL BCS NOTLK ; TEST IF CHANNEL READYTALK1 LDX LINDX ; IF SO, GET INDEX LDA CHNRDY,X ; GET BUFFER NUMBER BMI TLK10 ; IF READ CHANNEL, GO TALKNOTLKTLK05 RTS ; ELSE EXIT;;CODE ADDED TO CORRECT VERIFY ERRORTLK10 LDA #DAV+TR+EOI+ATNA ; SET OUTPUTS STA DDRB1 ; SWITCH OUTPUTS LDA #$FF ; SET DATA STA DDRA1 ; TO OUTPUTS LDA PB ; GET BUS LINES ORA #TR ; TRANSMIT MODE STA PB ; FOR BUFFERS LDA #NRFD ; GET MASKTLK20 BIT PB BMI NOTATN ; IF ATN, SERVICE IT BEQ TLK20 ; ELSE WAIT FOR ANY OTHER BUS LINE TO GO TRUE LDA CHNDAT,X ; THEN GET CHANNEL DATA EOR #$FF ; INVERT IT STA IEEED ; PUT ON BUS LDA CHNRDY,X ; GET CHANNEL STATE ORA #ATN+$20+TR+NRFD+NDAC+ATNA AND PB ; ADD BUS FLAGS STA PB ; AND SET BUSISR04 LDA PB ; GET BUS FLAGS BMI NOTATN ; IF ATN, GO SERVICE IT AND #NRFD+NDAC ; ELSE GET NRFD AND NDAC CMP #NRFD+NDAC ; IF BOTH TRUE BEQ TLK25 AND #NRFD ; IF NRFD FALSE BNE ISR04 ; WAIT UNTIL NRFD TRUE AND NDAC FALSETLK30 CLI ; THEN: JSR GET ; GET A BYTE FROM CHANNEL SEI ; NO INTERRUPTS LDA #NDAC ; GET MASK FOR NDAC FALSETLK35 BIT PB ; GET BUS LINES BMI NOTATN ; IF ATN, GO SERVICE IT BEQ TLK35 ; IF NDAC TRUE, WAITTLKRTN LDA #$FF ; DATA ACCEPTED, SET BUS DATA TO ZERO STA IEEED ; ON BUS LDA #DAV+EOI ; SET DAV & EOI TRUE ORA PB ; ADD CURRENT BUS STATE STA PB ; SET BUS LDA #NDAC ; GET MASK FOR NDACTLK40 BIT PB BMI NOTATN ; IF ATN, GO SERVICE IT BNE TLK40 ; IF NDAC TRUE, WAIT FOR IT TO GO FALSE BEQ TALK1 ; AND KEEP ON TALKIN (BRANCH ALWAYS);NOTATN JMP ATNSRV ; GO SERVICE ATN;ITERR ; IEEE TALKER ERROR RECOVERY LDA PB ; GET BUS LINES ORA #DAV ; SET DAV FALSE STA PB ; SET BUS RTS ; AND EXIT;ILERR ; IEEE LISTENER ERROR RECOVERY LDA #NRFD ; GET MASK FOR NRFD TRUE ORA PB ; ADD TO BUS STATE AND #$FF-ATNA ; SET ATN FALSE STA PB ; SET BUS RTS ; AND EXIT;;.END